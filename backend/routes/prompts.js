const express = require('express');
const router = express.Router();
const auth = require('../middleware/auth');
const aiService = require('../services/aiService');
const PromptService = require('../services/promptService');
const ProjectService = require('../services/projectService');
const UserService = require('../services/userService');

// Simple action generator for quick prototyping
function generateActionsFromPrompt(prompt) {
  const actions = [];
  const promptLower = prompt.toLowerCase();
  
  // Detect what user wants to create
  if (promptLower.includes('part') || promptLower.includes('block') || promptLower.includes('brick')) {
    actions.push({
      id: `action_${Date.now()}_1`,
      type: 'create_part',
      description: 'Creating a part',
      status: 'pending',
      data: {
        name: 'Part',
        className: 'Part',
        size: [4, 1, 2],
        position: [0, 5, 0],
        color: promptLower.includes('red') ? 'Bright red' : promptLower.includes('blue') ? 'Bright blue' : 'Medium stone grey',
        material: 'Plastic',
        anchored: true,
        parent: 'Workspace'
      }
    });
  }
  
  if (promptLower.includes('script')) {
    actions.push({
      id: `action_${Date.now()}_2`,
      type: 'create_script',
      description: 'Creating a script',
      status: 'pending',
      data: {
        name: 'GameScript',
        scriptType: promptLower.includes('local') ? 'LocalScript' : 'Script',
        code: `-- Generated by Hideout Bot\nprint("Hello from Hideout Bot!")`,
        parent: 'ServerScriptService'
      }
    });
  }
  
  if (promptLower.includes('ui') || promptLower.includes('gui') || promptLower.includes('button')) {
    actions.push({
      id: `action_${Date.now()}_3`,
      type: 'create_ui',
      description: 'Creating UI elements',
      status: 'pending',
      data: {
        name: 'GameUI',
        service: 'StarterGui',
        elements: [{
          className: 'TextButton',
          properties: {
            Name: 'MainButton',
            Size: [0, 200, 0, 50],
            Position: [0.5, -100, 0.5, -25],
            Text: 'Click Me!',
            BackgroundColor3: [0.4, 0.5, 0.9],
            TextColor3: [1, 1, 1],
            TextSize: 24
          }
        }]
      }
    });
  }
  
  if (promptLower.includes('terrain') || promptLower.includes('ground') || promptLower.includes('floor')) {
    actions.push({
      id: `action_${Date.now()}_4`,
      type: 'terrain_generate',
      description: 'Generating terrain',
      status: 'pending',
      data: {
        clear: false,
        generate: true,
        region: {
          min: [-100, 0, -100],
          max: [100, 5, 100]
        },
        material: 'Grass'
      }
    });
  }
  
  // If no specific action detected, create a simple part
  if (actions.length === 0) {
    actions.push({
      id: `action_${Date.now()}_1`,
      type: 'create_part',
      description: `Creating: ${prompt}`,
      status: 'pending',
      data: {
        name: 'GeneratedPart',
        className: 'Part',
        size: [5, 5, 5],
        position: [0, 5, 0],
        color: 'Bright blue',
        material: 'Plastic',
        anchored: true,
        parent: 'Workspace'
      }
    });
  }
  
  return actions;
}

// Create prompt endpoint (with automatic action generation for plugin)
router.post('/create', auth, async (req, res) => {
  try {
    const { prompt, projectId } = req.body;
    const user = req.user;
    
    if (!prompt) {
      return res.status(400).json({ error: 'Prompt is required' });
    }
    
    // Generate actions automatically from the prompt
    const actions = generateActionsFromPrompt(prompt);
    
    const aiResponse = {
      actions,
      message: `I'll build that for you! The plugin will execute ${actions.length} action(s).`,
      timestamp: new Date().toISOString()
    };
    
    // Save prompt with generated actions
    const promptDoc = await PromptService.create({
      userId: user.id,
      projectId: projectId || 'default-project',
      prompt,
      aiResponse,
      status: 'pending'
    });
    
    // Emit to WebSocket for instant sync
    const io = req.app.get('io');
    if (io && user.api_key) {
      io.to(`user_${user.api_key}`).emit('new_actions', {
        promptId: promptDoc.id,
        projectId: projectId || 'default-project',
        actions: actions
      });
      
      // Also emit action_queued event
      io.to(`user_${user.api_key}`).emit('actions_queued', {
        count: actions.length,
        descriptions: actions.map(a => a.description)
      });
    }
    
    console.log(`âœ… Created prompt with ${actions.length} actions for project ${projectId || 'default-project'}`);
    
    res.json({
      success: true,
      id: promptDoc.id,
      message: aiResponse.message,
      actions,
      projectId: projectId || 'default-project'
    });
  } catch (error) {
    console.error('Create prompt error:', error);
    res.status(500).json({ error: error.message });
  }
});

router.post('/submit', auth, async (req, res) => {
  try {
    const { prompt, projectId } = req.body;
    const user = req.user;
    
    // Reset daily limit if needed
    await UserService.resetIfNewDay(user.id);
    
    // Check prompt limit
    const isOwner = UserService.isOwner(user);
    if (!isOwner && user.prompts_used >= user.prompt_limit) {
      return res.status(429).json({
        error: 'Daily prompt limit reached',
        promptsLeft: 0,
        resetsAt: getNextMidnight()
      });
    }
    
    // Use a prompt
    if (!isOwner) {
      await UserService.usePrompt(user.id);
    }
    
    // Get project context if provided
    let projectContext = {};
    if (projectId) {
      const project = await ProjectService.findById(projectId);
      projectContext = project ? project.context : {};
    }
    
    // Process with AI
    const aiResponse = await aiService.processPrompt(prompt, projectContext);
    
    // Save prompt to database
    const promptDoc = await PromptService.create({
      userId: user.id,
      projectId,
      prompt,
      aiResponse,
      status: 'pending'
    });
    
    // Emit to socket if available
    const io = req.app.get('io');
    if (io) {
      io.to(`user_${user.api_key}`).emit('new_actions', {
        promptId: promptDoc.id,
        actions: aiResponse.actions
      });
    }
    
    res.json({
      success: true,
      promptId: promptDoc.id,
      plan: aiResponse.plan,
      actions: aiResponse.actions,
      promptsLeft: isOwner ? 'unlimited' : user.prompt_limit - user.prompts_used
    });
  } catch (error) {
    console.error('Submit prompt error:', error);
    res.status(500).json({ error: error.message });
  }
});

router.get('/status/:id', auth, async (req, res) => {
  try {
    const prompt = await PromptService.findById(req.params.id);
    if (!prompt) {
      return res.status(404).json({ error: 'Prompt not found' });
    }
    res.json(prompt);
  } catch (error) {
    console.error('Get prompt status error:', error);
    res.status(500).json({ error: error.message });
  }
});

router.get('/history', auth, async (req, res) => {
  try {
    const prompts = await PromptService.findByUserId(req.user.id, 50);
    res.json(prompts);
  } catch (error) {
    console.error('Get prompt history error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Update prompt status
router.put('/:id/status', auth, async (req, res) => {
  try {
    const { status } = req.body;
    const prompt = await PromptService.update(req.params.id, { status });
    res.json({ success: true, prompt });
  } catch (error) {
    console.error('Update prompt status error:', error);
    res.status(500).json({ error: error.message });
  }
});

function getNextMidnight() {
  const tomorrow = new Date();
  tomorrow.setDate(tomorrow.getDate() + 1);
  tomorrow.setHours(0, 0, 0, 0);
  return tomorrow;
}

module.exports = router;
